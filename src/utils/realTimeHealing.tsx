/**
 * Real-Time Healing React Components
 *
 * Advanced React components and hooks for real-time self-healing
 * Features silent, cutting-edge healing with zero user disruption
 */

import React, {
  useEffect,
  useRef,
  useState,
  useCallback,
  useMemo,
} from 'react';
import advancedSelfHealing from './advancedSelfHealing';

// Advanced Error Boundary with predictive healing
export class AdvancedErrorBoundary extends React.Component<
  {
    children: React.ReactNode;
    fallback?: React.ComponentType<any>;
    silent?: boolean;
  },
  { hasError: boolean; errorId?: string; healingAttempts: number }
> {
  private healingTimer?: NodeJS.Timeout;
  private performanceObserver?: PerformanceObserver;

  constructor(props: any) {
    super(props);
    this.state = {
      hasError: false,
      healingAttempts: 0,
    };
  }

  static getDerivedStateFromError(error: Error) {
    return { hasError: true, errorId: error.message };
  }

  async componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    const context = {
      componentStack: errorInfo.componentStack,
      errorBoundary: true,
      props: this.props,
    };

    // Attempt immediate healing
    const healed = await advancedSelfHealing.healError(error, context);

    if (healed && this.state.healingAttempts < 3) {
      // Silent recovery
      this.healingTimer = setTimeout(
        () => {
          this.setState({
            hasError: false,
            healingAttempts: this.state.healingAttempts + 1,
          });
        },
        this.props.silent ? 0 : 100,
      );
    }
  }

  componentWillUnmount() {
    if (this.healingTimer) {
      clearTimeout(this.healingTimer);
    }
    if (this.performanceObserver) {
      this.performanceObserver.disconnect();
    }
  }

  render() {
    if (this.state.hasError && !this.props.silent) {
      const FallbackComponent = this.props.fallback;
      if (FallbackComponent) {
        return <FallbackComponent />;
      }

      // Invisible fallback for silent mode
      return <div style={{ display: 'none' }} />;
    }

    return this.props.children;
  }
}

// Real-time performance monitoring hook
export function useRealTimeHealing() {
  const [metrics, setMetrics] = useState({
    memoryUsage: 0,
    renderTime: 0,
    errorRate: 0,
    healingActive: false,
  });

  const performanceRef = useRef<PerformanceObserver>();
  const memoryRef = useRef<number>(0);

  useEffect(() => {
    // Monitor component performance
    if ('PerformanceObserver' in window) {
      performanceRef.current = new PerformanceObserver(list => {
        const entries = list.getEntries();
        const renderEntries = entries.filter(
          entry => entry.entryType === 'measure',
        );

        if (renderEntries.length > 0) {
          const avgRenderTime =
            renderEntries.reduce((sum, entry) => sum + entry.duration, 0) /
            renderEntries.length;

          setMetrics(prev => ({
            ...prev,
            renderTime: avgRenderTime,
            healingActive: avgRenderTime > 16.67, // 60fps threshold
          }));

          // Auto-optimize if performance degrades
          if (avgRenderTime > 50) {
            advancedSelfHealing.healError(
              new Error('Performance degradation'),
              {
                renderTime: avgRenderTime,
                component: 'useRealTimeHealing',
              },
            );
          }
        }
      });

      performanceRef.current.observe({ entryTypes: ['measure'] });
    }

    // Memory monitoring
    const memoryInterval = setInterval(() => {
      if ('memory' in performance) {
        const memory = (performance as any).memory;
        const currentUsage = memory.usedJSHeapSize;

        setMetrics(prev => ({
          ...prev,
          memoryUsage: currentUsage,
        }));

        // Detect memory leaks
        if (currentUsage > memoryRef.current * 1.5 && memoryRef.current > 0) {
          advancedSelfHealing.healError(new Error('Memory leak detected'), {
            previousUsage: memoryRef.current,
            currentUsage,
            component: 'useRealTimeHealing',
          });
        }

        memoryRef.current = currentUsage;
      }
    }, 5000);

    return () => {
      if (performanceRef.current) {
        performanceRef.current.disconnect();
      }
      clearInterval(memoryInterval);
    };
  }, []);

  return metrics;
}

// Self-healing fetch hook with advanced retry strategies
export function useSelfHealingFetch() {
  const [requestCache] = useState(new Map<string, any>());
  const [networkMetrics, setNetworkMetrics] = useState({
    latency: 0,
    successRate: 100,
    activeRequests: 0,
  });

  const adaptiveFetch = useCallback(
    async (
      url: string,
      options?: RequestInit,
      healingOptions?: {
        maxRetries?: number;
        timeout?: number;
        cacheStrategy?: 'none' | 'memory' | 'persistent';
        fallbackData?: any;
      },
    ) => {
      const {
        maxRetries = 5,
        timeout = 10000,
        cacheStrategy = 'memory',
        fallbackData,
      } = healingOptions || {};

      const cacheKey = `${url}-${JSON.stringify(options)}`;

      // Check cache first
      if (cacheStrategy !== 'none' && requestCache.has(cacheKey)) {
        const cached = requestCache.get(cacheKey);
        if (Date.now() - cached.timestamp < 60000) {
          // 1 minute cache
          return cached.data;
        }
      }

      setNetworkMetrics(prev => ({
        ...prev,
        activeRequests: prev.activeRequests + 1,
      }));

      let lastError: Error | null = null;
      const startTime = performance.now();

      for (let attempt = 0; attempt < maxRetries; attempt++) {
        try {
          const controller = new AbortController();
          const timeoutId = setTimeout(
            () => controller.abort(),
            timeout + attempt * 1000,
          );

          const response = await fetch(url, {
            ...options,
            signal: controller.signal,
          });

          clearTimeout(timeoutId);

          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }

          const data = await response.json();
          const endTime = performance.now();
          const latency = endTime - startTime;

          // Update metrics
          setNetworkMetrics(prev => ({
            latency: prev.latency * 0.8 + latency * 0.2,
            successRate: Math.min(100, prev.successRate + 1),
            activeRequests: prev.activeRequests - 1,
          }));

          // Cache successful response
          if (cacheStrategy !== 'none') {
            requestCache.set(cacheKey, {
              data,
              timestamp: Date.now(),
            });
          }

          return data;
        } catch (error) {
          lastError = error as Error;

          // Adaptive delay based on error type and attempt
          const delay = Math.min(
            1000 * Math.pow(2, attempt),
            error.name === 'AbortError' ? 5000 : 2000,
          );

          if (attempt < maxRetries - 1) {
            await new Promise(resolve => setTimeout(resolve, delay));

            // Attempt healing
            await advancedSelfHealing.healError(lastError, {
              url,
              options,
              attempt,
              networkMetrics,
            });
          }
        }
      }

      // Update failure metrics
      setNetworkMetrics(prev => ({
        ...prev,
        successRate: Math.max(0, prev.successRate - 5),
        activeRequests: prev.activeRequests - 1,
      }));

      // Return fallback data if available
      if (fallbackData) {
        return fallbackData;
      }

      throw lastError || new Error('Request failed after all retries');
    },
    [requestCache],
  );

  return { adaptiveFetch, networkMetrics };
}

// Self-healing state management hook
export function useSelfHealingState<T>(
  initialState: T,
  validator?: (state: T) => boolean,
  healer?: (corruptedState: T) => T,
) {
  const [state, setState] = useState<T>(initialState);
  const [stateHistory] = useState<T[]>([]);
  const backupRef = useRef<T>(initialState);

  // Validate and heal state on every update
  const setSafeState = useCallback(
    (newState: T | ((prev: T) => T)) => {
      const nextState =
        typeof newState === 'function'
          ? (newState as (prev: T) => T)(state)
          : newState;

      // Validate state
      if (validator && !validator(nextState)) {
        // Attempt healing
        const healedState = healer ? healer(nextState) : backupRef.current;

        advancedSelfHealing.healError(new Error('Invalid state detected'), {
          component: 'useSelfHealingState',
          corruptedState: nextState,
          healedState,
        });

        setState(healedState);
        return;
      }

      // Store backup
      backupRef.current = state;
      stateHistory.push(state);

      // Keep only last 10 states
      if (stateHistory.length > 10) {
        stateHistory.shift();
      }

      setState(nextState);
    },
    [state, validator, healer, stateHistory],
  );

  // Recovery function
  const recoverState = useCallback(() => {
    const lastValidState =
      stateHistory[stateHistory.length - 1] || initialState;
    setState(lastValidState);
  }, [stateHistory, initialState]);

  return [state, setSafeState, recoverState] as const;
}

// Advanced component wrapper with predictive healing
export function withAdvancedHealing<P extends object>(
  Component: React.ComponentType<P>,
  options?: {
    silent?: boolean;
    predictive?: boolean;
    performanceMonitoring?: boolean;
    stateBackup?: boolean;
  },
) {
  const {
    silent = true,
    predictive = true,
    performanceMonitoring = true,
    stateBackup = true,
  } = options || {};

  return React.forwardRef<any, P>((props, ref) => {
    const componentRef = useRef<any>(null);
    const renderCountRef = useRef(0);
    const lastRenderTime = useRef(performance.now());

    // Performance monitoring
    const healingMetrics = useRealTimeHealing();

    // Predictive error prevention
    useEffect(() => {
      if (predictive) {
        const checkInterval = setInterval(() => {
          const now = performance.now();
          const renderDelta = now - lastRenderTime.current;

          // Predict potential issues
          if (renderDelta > 100 && renderCountRef.current > 10) {
            advancedSelfHealing.healError(
              new Error('Potential performance issue'),
              {
                component: Component.name,
                renderCount: renderCountRef.current,
                renderDelta,
                predictive: true,
              },
            );
          }
        }, 5000);

        return () => clearInterval(checkInterval);
      }
    }, []);

    // Track renders
    useEffect(() => {
      renderCountRef.current++;
      lastRenderTime.current = performance.now();
    });

    const WrappedComponent = useMemo(() => {
      return React.forwardRef<any, P>((innerProps, innerRef) => {
        try {
          return <Component {...innerProps} ref={innerRef || componentRef} />;
        } catch (error) {
          // Immediate healing attempt
          advancedSelfHealing.healError(error as Error, {
            component: Component.name,
            props: innerProps,
            renderCount: renderCountRef.current,
          });

          // Return minimal fallback
          return silent ? (
            <div style={{ display: 'none' }} />
          ) : (
            <div>Loading...</div>
          );
        }
      });
    }, []);

    return (
      <AdvancedErrorBoundary silent={silent}>
        <WrappedComponent {...props} ref={ref} />
      </AdvancedErrorBoundary>
    );
  });
}

// Real-time system health monitor component
export const SystemHealthMonitor: React.FC<{ visible?: boolean }> = ({
  visible = false,
}) => {
  const [health, setHealth] = useState({
    status: 'optimal',
    healingActive: false,
    errorRate: 0,
    performance: 100,
  });

  useEffect(() => {
    const interval = setInterval(() => {
      // This would integrate with the advancedSelfHealing to get real metrics
      setHealth({
        status: 'optimal',
        healingActive: false,
        errorRate: 0,
        performance: 100,
      });
    }, 1000);

    return () => clearInterval(interval);
  }, []);

  if (!visible) {
    return null;
  }

  return (
    <div
      style={{
        position: 'fixed',
        top: 10,
        right: 10,
        background: 'rgba(0,0,0,0.8)',
        color: 'white',
        padding: '10px',
        borderRadius: '5px',
        fontSize: '12px',
        zIndex: 9999,
      }}
    >
      <div>Status: {health.status}</div>
      <div>Healing: {health.healingActive ? 'Active' : 'Standby'}</div>
      <div>Errors: {health.errorRate}/min</div>
      <div>Performance: {health.performance}%</div>
    </div>
  );
};

export default {
  AdvancedErrorBoundary,
  useRealTimeHealing,
  useSelfHealingFetch,
  useSelfHealingState,
  withAdvancedHealing,
  SystemHealthMonitor,
};
