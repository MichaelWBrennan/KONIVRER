import React, { createContext, useContext, useReducer, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';

// Advanced Game Engine Context for MTG Arena-quality gameplay
const GameEngineContext = createContext();

// Game States
const GAME_STATES = {
  MENU: 'menu',
  MATCHMAKING: 'matchmaking',
  MULLIGAN: 'mulligan',
  PLAYING: 'playing',
  STACK_RESOLUTION: 'stack_resolution',
  COMBAT: 'combat',
  GAME_OVER: 'game_over',
  SPECTATING: 'spectating'
};

// Turn Phases (MTG-style)
const TURN_PHASES = {
  UNTAP: 'untap',
  UPKEEP: 'upkeep',
  DRAW: 'draw',
  MAIN1: 'main1',
  COMBAT_BEGIN: 'combat_begin',
  DECLARE_ATTACKERS: 'declare_attackers',
  DECLARE_BLOCKERS: 'declare_blockers',
  COMBAT_DAMAGE: 'combat_damage',
  COMBAT_END: 'combat_end',
  MAIN2: 'main2',
  END: 'end',
  CLEANUP: 'cleanup'
};

// Priority System (Legends of Runeterra style)
const PRIORITY_STATES = {
  ACTIVE_PLAYER: 'active_player',
  NON_ACTIVE_PLAYER: 'non_active_player',
  BOTH_PASS: 'both_pass',
  STACK_RESOLVING: 'stack_resolving'
};

// Initial game state
const initialState = {
  // Game Management
  gameState: GAME_STATES.MENU,
  gameId: null,
  players: [],
  currentPlayer: 0,
  turnNumber: 1,
  phase: TURN_PHASES.UNTAP,
  priority: PRIORITY_STATES.ACTIVE_PLAYER,
  
  // Interactive Systems
  stack: [], // Spell/ability stack
  pendingActions: [],
  awaitingResponse: false,
  responseTimer: null,
  
  // Game Objects
  battlefield: [],
  graveyards: [[], []],
  hands: [[], []],
  libraries: [[], []],
  exile: [[], []],
  
  // Game Rules
  lifeTotal: [20, 20],
  manaPool: [{}, {}],
  landsPlayedThisTurn: [0, 0],
  
  // Visual Effects
  animations: [],
  soundQueue: [],
  
  // Mobile Optimizations
  autoPass: false,
  smartTargeting: true,
  gestureControls: true,
  
  // Spectator Mode
  spectators: [],
  replayMode: false,
  
  // Performance
  frameRate: 60,
  lowDataMode: false,
  
  // Anti-cheat
  serverValidation: true,
  actionHistory: [],
  
  // Analytics
  gameStats: {
    startTime: null,
    endTime: null,
    totalActions: 0,
    averageResponseTime: 0
  }
};

// Action types
const ACTIONS = {
  // Game Flow
  START_GAME: 'START_GAME',
  END_GAME: 'END_GAME',
  NEXT_PHASE: 'NEXT_PHASE',
  PASS_PRIORITY: 'PASS_PRIORITY',
  
  // Card Actions
  PLAY_CARD: 'PLAY_CARD',
  ACTIVATE_ABILITY: 'ACTIVATE_ABILITY',
  ATTACK: 'ATTACK',
  BLOCK: 'BLOCK',
  
  // Stack Management
  ADD_TO_STACK: 'ADD_TO_STACK',
  RESOLVE_STACK: 'RESOLVE_STACK',
  COUNTER_SPELL: 'COUNTER_SPELL',
  
  // Zone Changes
  MOVE_CARD: 'MOVE_CARD',
  SHUFFLE_LIBRARY: 'SHUFFLE_LIBRARY',
  DRAW_CARD: 'DRAW_CARD',
  
  // Visual Effects
  ADD_ANIMATION: 'ADD_ANIMATION',
  REMOVE_ANIMATION: 'REMOVE_ANIMATION',
  PLAY_SOUND: 'PLAY_SOUND',
  
  // Mobile Features
  TOGGLE_AUTO_PASS: 'TOGGLE_AUTO_PASS',
  SET_GESTURE_MODE: 'SET_GESTURE_MODE',
  
  // Performance
  SET_FRAME_RATE: 'SET_FRAME_RATE',
  TOGGLE_LOW_DATA: 'TOGGLE_LOW_DATA',
  
  // Analytics
  TRACK_ACTION: 'TRACK_ACTION',
  UPDATE_STATS: 'UPDATE_STATS'
};

// Game Engine Reducer
function gameEngineReducer(state, action) {
  switch (action.type) {
    case ACTIONS.START_GAME:
      return {
        ...state,
        gameState: GAME_STATES.PLAYING,
        gameId: action.payload.gameId,
        players: action.payload.players,
        gameStats: {
          ...state.gameStats,
          startTime: Date.now()
        }
      };

    case ACTIONS.NEXT_PHASE:
      const phases = Object.values(TURN_PHASES);
      const currentPhaseIndex = phases.indexOf(state.phase);
      const nextPhaseIndex = (currentPhaseIndex + 1) % phases.length;
      
      return {
        ...state,
        phase: phases[nextPhaseIndex],
        // Switch players if we're back to untap
        currentPlayer: nextPhaseIndex === 0 ? 1 - state.currentPlayer : state.currentPlayer,
        turnNumber: nextPhaseIndex === 0 ? state.turnNumber + 1 : state.turnNumber
      };

    case ACTIONS.ADD_TO_STACK:
      return {
        ...state,
        stack: [...state.stack, action.payload],
        awaitingResponse: true,
        priority: PRIORITY_STATES.NON_ACTIVE_PLAYER
      };

    case ACTIONS.RESOLVE_STACK:
      if (state.stack.length === 0) return state;
      
      const resolving = state.stack[state.stack.length - 1];
      return {
        ...state,
        stack: state.stack.slice(0, -1),
        // Apply spell/ability effects here
        animations: [...state.animations, {
          id: Date.now(),
          type: 'spell_resolution',
          card: resolving,
          duration: 1000
        }]
      };

    case ACTIONS.PLAY_CARD:
      return {
        ...state,
        // Move card from hand to stack/battlefield
        hands: state.hands.map((hand, index) => 
          index === action.payload.player 
            ? hand.filter(card => card.id !== action.payload.card.id)
            : hand
        ),
        stack: action.payload.card.type === 'instant' || action.payload.card.type === 'sorcery'
          ? [...state.stack, action.payload.card]
          : state.stack,
        battlefield: action.payload.card.type === 'creature' || action.payload.card.type === 'artifact'
          ? [...state.battlefield, { ...action.payload.card, controller: action.payload.player }]
          : state.battlefield,
        animations: [...state.animations, {
          id: Date.now(),
          type: 'card_play',
          card: action.payload.card,
          player: action.payload.player,
          duration: 800
        }],
        gameStats: {
          ...state.gameStats,
          totalActions: state.gameStats.totalActions + 1
        }
      };

    case ACTIONS.ADD_ANIMATION:
      return {
        ...state,
        animations: [...state.animations, {
          id: Date.now(),
          ...action.payload,
          startTime: Date.now()
        }]
      };

    case ACTIONS.REMOVE_ANIMATION:
      return {
        ...state,
        animations: state.animations.filter(anim => anim.id !== action.payload.id)
      };

    case ACTIONS.TOGGLE_AUTO_PASS:
      return {
        ...state,
        autoPass: !state.autoPass
      };

    case ACTIONS.SET_FRAME_RATE:
      return {
        ...state,
        frameRate: action.payload.frameRate
      };

    case ACTIONS.TRACK_ACTION:
      return {
        ...state,
        actionHistory: [...state.actionHistory, {
          timestamp: Date.now(),
          action: action.payload.action,
          player: action.payload.player,
          data: action.payload.data
        }]
      };

    default:
      return state;
  }
}

// Advanced Game Engine Provider
export const GameEngineProvider = ({ children }) => {
  const [state, dispatch] = useReducer(gameEngineReducer, initialState);

  // Auto-cleanup animations
  useEffect(() => {
    const interval = setInterval(() => {
      const now = Date.now();
      state.animations.forEach(animation => {
        if (now - animation.startTime > animation.duration) {
          dispatch({
            type: ACTIONS.REMOVE_ANIMATION,
            payload: { id: animation.id }
          });
        }
      });
    }, 100);

    return () => clearInterval(interval);
  }, [state.animations]);

  // Performance monitoring
  useEffect(() => {
    let frameCount = 0;
    let lastTime = performance.now();

    const measureFPS = () => {
      frameCount++;
      const currentTime = performance.now();
      
      if (currentTime - lastTime >= 1000) {
        const fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
        
        // Adjust quality based on performance
        if (fps < 30 && state.frameRate > 30) {
          dispatch({
            type: ACTIONS.SET_FRAME_RATE,
            payload: { frameRate: 30 }
          });
        }
        
        frameCount = 0;
        lastTime = currentTime;
      }
      
      requestAnimationFrame(measureFPS);
    };

    requestAnimationFrame(measureFPS);
  }, []);

  // Game Engine API
  const gameEngine = {
    // State
    ...state,
    
    // Core Actions
    startGame: (gameConfig) => {
      dispatch({
        type: ACTIONS.START_GAME,
        payload: gameConfig
      });
    },

    playCard: (card, player, targets = []) => {
      // Validate play legality
      if (!canPlayCard(card, player, state)) {
        return false;
      }

      dispatch({
        type: ACTIONS.PLAY_CARD,
        payload: { card, player, targets }
      });

      // Track for analytics
      dispatch({
        type: ACTIONS.TRACK_ACTION,
        payload: {
          action: 'play_card',
          player,
          data: { cardId: card.id, cardName: card.name }
        }
      });

      return true;
    },

    passPriority: () => {
      dispatch({ type: ACTIONS.PASS_PRIORITY });
    },

    nextPhase: () => {
      dispatch({ type: ACTIONS.NEXT_PHASE });
    },

    // Interactive Systems
    addToStack: (spell) => {
      dispatch({
        type: ACTIONS.ADD_TO_STACK,
        payload: spell
      });
    },

    resolveStack: () => {
      dispatch({ type: ACTIONS.RESOLVE_STACK });
    },

    // Visual Effects
    addAnimation: (animationData) => {
      dispatch({
        type: ACTIONS.ADD_ANIMATION,
        payload: animationData
      });
    },

    playSound: (soundId, volume = 1.0) => {
      // Sound system integration
      if (!state.lowDataMode) {
        dispatch({
          type: ACTIONS.PLAY_SOUND,
          payload: { soundId, volume }
        });
      }
    },

    // Mobile Optimizations
    toggleAutoPass: () => {
      dispatch({ type: ACTIONS.TOGGLE_AUTO_PASS });
    },

    setGestureMode: (enabled) => {
      dispatch({
        type: ACTIONS.SET_GESTURE_MODE,
        payload: { enabled }
      });
    },

    // Performance Controls
    toggleLowDataMode: () => {
      dispatch({ type: ACTIONS.TOGGLE_LOW_DATA });
    },

    // Utility Functions
    canPlayCard: (card, player) => canPlayCard(card, player, state),
    getValidTargets: (card, player) => getValidTargets(card, player, state),
    calculateDamage: (attacker, blocker) => calculateDamage(attacker, blocker, state)
  };

  return (
    <GameEngineContext.Provider value={gameEngine}>
      {children}
    </GameEngineContext.Provider>
  );
};

// Utility Functions
function canPlayCard(card, player, state) {
  // Check if it's the player's turn and they have priority
  if (state.currentPlayer !== player) return false;
  if (state.priority !== PRIORITY_STATES.ACTIVE_PLAYER) return false;
  
  // Check mana requirements
  if (!hasEnoughMana(card.cost, state.manaPool[player])) return false;
  
  // Check timing restrictions
  if (card.type === 'sorcery' && state.phase !== TURN_PHASES.MAIN1 && state.phase !== TURN_PHASES.MAIN2) {
    return false;
  }
  
  return true;
}

function hasEnoughMana(cost, manaPool) {
  // Simplified mana checking
  const totalAvailable = Object.values(manaPool).reduce((sum, amount) => sum + amount, 0);
  const totalRequired = Object.values(cost).reduce((sum, amount) => sum + amount, 0);
  return totalAvailable >= totalRequired;
}

function getValidTargets(card, player, state) {
  // Return valid targets for the card
  const targets = [];
  
  if (card.targetType === 'creature') {
    targets.push(...state.battlefield.filter(permanent => permanent.type === 'creature'));
  }
  
  if (card.targetType === 'player') {
    targets.push(...state.players);
  }
  
  return targets;
}

function calculateDamage(attacker, blocker, state) {
  // Combat damage calculation
  return {
    attackerDamage: blocker ? blocker.toughness : 0,
    blockerDamage: attacker.power,
    trample: attacker.abilities?.includes('trample') || false
  };
}

// Hook to use the game engine
export const useGameEngine = () => {
  const context = useContext(GameEngineContext);
  if (!context) {
    throw new Error('useGameEngine must be used within a GameEngineProvider');
  }
  return context;
};

// Export constants for use in components
export { GAME_STATES, TURN_PHASES, PRIORITY_STATES, ACTIONS };