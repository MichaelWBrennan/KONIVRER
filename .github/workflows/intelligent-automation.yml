# MIT License
# 
# Copyright (c) 2025 KONIVRER Team
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.

name: Intelligent Issue & PR Automation

on:
  issues:
    types: [opened, edited, labeled, assigned]
  pull_request:
    types: [opened, edited, synchronize, ready_for_review, review_requested]
  pull_request_review:
    types: [submitted]
  schedule:
    # Clean up stale issues and PRs daily at 5 AM UTC
    - cron: '0 5 * * *'
  workflow_dispatch:

permissions:
  contents: write
  issues: write
  pull-requests: write
  checks: write
  actions: read

concurrency:
  group: intelligent-automation-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # Intelligent issue triage
  issue-triage:
    name: Intelligent Issue Triage
    runs-on: ubuntu-latest
    if: github.event_name == 'issues' && github.event.action == 'opened'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Analyze issue content
      id: analyze
      uses: actions/github-script@v7
      with:
        script: |
          const issue = context.payload.issue;
          const title = issue.title.toLowerCase();
          const body = issue.body?.toLowerCase() || '';
          
          // Determine issue type and priority
          let labels = [];
          let priority = 'medium';
          let assignees = [];
          
          // Bug detection
          if (title.includes('bug') || title.includes('error') || title.includes('broken') || 
              body.includes('error') || body.includes('exception') || body.includes('crash')) {
            labels.push('bug');
            if (title.includes('critical') || body.includes('production') || body.includes('urgent')) {
              priority = 'high';
              labels.push('urgent');
            }
          }
          
          // Feature request detection
          if (title.includes('feature') || title.includes('enhancement') || title.includes('add') ||
              body.includes('feature request') || body.includes('enhancement')) {
            labels.push('enhancement');
          }
          
          // Documentation issues
          if (title.includes('doc') || title.includes('readme') || body.includes('documentation')) {
            labels.push('documentation');
          }
          
          // Security issues
          if (title.includes('security') || title.includes('vulnerability') || 
              body.includes('security') || body.includes('cve')) {
            labels.push('security');
            priority = 'high';
            labels.push('urgent');
          }
          
          // Performance issues
          if (title.includes('performance') || title.includes('slow') || title.includes('optimization')) {
            labels.push('performance');
          }
          
          // Question/help
          if (title.includes('question') || title.includes('help') || title.includes('how to')) {
            labels.push('question');
            priority = 'low';
          }
          
          // Add priority label
          labels.push(`priority-${priority}`);
          
          return { labels, priority, assignees };
          
    - name: Apply intelligent labels
      uses: actions/github-script@v7
      with:
        script: |
          const analysis = ${{ steps.analyze.outputs.result }};
          
          await github.rest.issues.addLabels({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number,
            labels: analysis.labels
          });
          
    - name: Add helpful comment
      uses: actions/github-script@v7
      with:
        script: |
          const analysis = ${{ steps.analyze.outputs.result }};
          const issue = context.payload.issue;
          
          let comment = `üëã Thank you for opening this issue!\n\n`;
          
          if (analysis.labels.includes('bug')) {
            comment += `üêõ This appears to be a bug report. To help us resolve this quickly, please ensure you've included:
            - Steps to reproduce the issue
            - Expected vs actual behavior
            - Browser/environment details
            - Any error messages or console logs\n\n`;
          }
          
          if (analysis.labels.includes('enhancement')) {
            comment += `‚ú® This looks like a feature request! We appreciate your suggestion. Please consider:
            - Describing the use case and benefits
            - Providing mockups or examples if applicable
            - Checking if similar features already exist\n\n`;
          }
          
          if (analysis.labels.includes('security')) {
            comment += `üîí **Security Issue Detected** - This issue has been marked as security-related and will be prioritized accordingly.\n\n`;
          }
          
          comment += `I've automatically labeled this issue based on its content. A maintainer will review it soon.\n\n`;
          comment += `**Priority:** ${analysis.priority.toUpperCase()}`;
          
          await github.rest.issues.createComment({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number,
            body: comment
          });

  # Intelligent PR automation
  pr-automation:
    name: Intelligent PR Automation
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Analyze PR changes
      id: analyze-pr
      uses: actions/github-script@v7
      with:
        script: |
          const pr = context.payload.pull_request;
          const files = await github.rest.pulls.listFiles({
            owner: context.repo.owner,
            repo: context.repo.repo,
            pull_number: pr.number
          });
          
          let labels = [];
          let reviewers = [];
          let priority = 'medium';
          
          const changedFiles = files.data.map(f => f.filename);
          const additions = files.data.reduce((sum, f) => sum + f.additions, 0);
          const deletions = files.data.reduce((sum, f) => sum + f.deletions, 0);
          
          // Analyze file types
          const hasJSChanges = changedFiles.some(f => f.match(/\.(js|jsx|ts|tsx)$/));
          const hasCSSChanges = changedFiles.some(f => f.match(/\.(css|scss|sass)$/));
          const hasConfigChanges = changedFiles.some(f => f.match(/\.(json|yml|yaml|toml)$/));
          const hasDocChanges = changedFiles.some(f => f.match(/\.(md|txt)$/));
          const hasWorkflowChanges = changedFiles.some(f => f.includes('.github/workflows'));
          const hasSecurityFiles = changedFiles.some(f => f.includes('security') || f.includes('auth'));
          
          // Determine labels
          if (hasJSChanges) labels.push('javascript');
          if (hasCSSChanges) labels.push('css');
          if (hasConfigChanges) labels.push('configuration');
          if (hasDocChanges) labels.push('documentation');
          if (hasWorkflowChanges) labels.push('ci/cd');
          if (hasSecurityFiles) {
            labels.push('security');
            priority = 'high';
          }
          
          // Size labels
          const totalChanges = additions + deletions;
          if (totalChanges < 10) labels.push('size/XS');
          else if (totalChanges < 30) labels.push('size/S');
          else if (totalChanges < 100) labels.push('size/M');
          else if (totalChanges < 500) labels.push('size/L');
          else labels.push('size/XL');
          
          // Determine if breaking changes
          const title = pr.title.toLowerCase();
          const body = pr.body?.toLowerCase() || '';
          if (title.includes('breaking') || body.includes('breaking change')) {
            labels.push('breaking-change');
            priority = 'high';
          }
          
          return { 
            labels, 
            reviewers, 
            priority, 
            hasJSChanges, 
            hasSecurityFiles, 
            totalChanges,
            changedFiles: changedFiles.length
          };
          
    - name: Apply PR labels
      uses: actions/github-script@v7
      with:
        script: |
          const analysis = ${{ steps.analyze-pr.outputs.result }};
          
          if (analysis.labels.length > 0) {
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              labels: analysis.labels
            });
          }
          
    - name: Auto-assign reviewers
      if: github.event.action == 'opened' || github.event.action == 'ready_for_review'
      uses: actions/github-script@v7
      with:
        script: |
          const analysis = ${{ steps.analyze-pr.outputs.result }};
          const pr = context.payload.pull_request;
          
          let reviewers = [];
          
          // Assign based on file types (customize these based on your team)
          if (analysis.hasJSChanges) {
            reviewers.push('frontend-team'); // Replace with actual usernames
          }
          
          if (analysis.hasSecurityFiles) {
            reviewers.push('security-team'); // Replace with actual usernames
          }
          
          // Don't assign reviewers to draft PRs or if author is a bot
          if (!pr.draft && !pr.user.login.includes('bot') && reviewers.length > 0) {
            try {
              await github.rest.pulls.requestReviewers({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number,
                reviewers: reviewers.slice(0, 2) // Limit to 2 reviewers
              });
            } catch (error) {
              console.log('Could not assign reviewers:', error.message);
            }
          }
          
    - name: Add PR analysis comment
      if: github.event.action == 'opened'
      uses: actions/github-script@v7
      with:
        script: |
          const analysis = ${{ steps.analyze-pr.outputs.result }};
          
          let comment = `ü§ñ **Automated PR Analysis**\n\n`;
          comment += `üìä **Change Summary:**\n`;
          comment += `- Files changed: ${analysis.changedFiles}\n`;
          comment += `- Total changes: ${analysis.totalChanges} lines\n`;
          comment += `- Priority: ${analysis.priority.toUpperCase()}\n\n`;
          
          comment += `üè∑Ô∏è **Auto-applied labels:** ${analysis.labels.join(', ')}\n\n`;
          
          if (analysis.hasSecurityFiles) {
            comment += `üîí **Security Notice:** This PR modifies security-related files. Extra review required.\n\n`;
          }
          
          comment += `‚úÖ **Next Steps:**\n`;
          comment += `- Ensure all tests pass\n`;
          comment += `- Request review from appropriate team members\n`;
          comment += `- Update documentation if needed\n`;
          
          await github.rest.issues.createComment({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number,
            body: comment
          });

  # Automated stale issue management
  stale-management:
    name: Stale Issue Management
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule'
    
    steps:
    - name: Mark stale issues
      uses: actions/stale@v9
      with:
        repo-token: ${{ secrets.GITHUB_TOKEN }}
        stale-issue-message: |
          üëã This issue has been automatically marked as stale because it has not had recent activity. 
          
          It will be closed if no further activity occurs within 7 days. If this issue is still relevant, please:
          - Add a comment to keep it open
          - Add the `keep-open` label
          - Provide additional context or updates
          
          Thank you for your contributions! üôè
        stale-pr-message: |
          üëã This pull request has been automatically marked as stale because it has not had recent activity.
          
          It will be closed if no further activity occurs within 7 days. If this PR is still relevant, please:
          - Rebase against the latest main branch
          - Address any review comments
          - Add a comment to keep it open
          
          Thank you for your contributions! üôè
        close-issue-message: |
          üîí This issue has been automatically closed due to inactivity. 
          
          If you believe this issue is still relevant, please reopen it with additional context or create a new issue referencing this one.
        close-pr-message: |
          üîí This pull request has been automatically closed due to inactivity.
          
          If you'd like to continue working on this, please reopen the PR or create a new one.
        days-before-stale: 30
        days-before-close: 7
        stale-issue-label: 'stale'
        stale-pr-label: 'stale'
        exempt-issue-labels: 'keep-open,security,urgent,pinned'
        exempt-pr-labels: 'keep-open,security,urgent,work-in-progress'

  # Automated milestone management
  milestone-management:
    name: Milestone Management
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule'
    
    steps:
    - name: Update milestone progress
      uses: actions/github-script@v7
      with:
        script: |
          // Get all open milestones
          const milestones = await github.rest.issues.listMilestones({
            owner: context.repo.owner,
            repo: context.repo.repo,
            state: 'open'
          });
          
          for (const milestone of milestones.data) {
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              milestone: milestone.number,
              state: 'all'
            });
            
            const totalIssues = issues.data.length;
            const closedIssues = issues.data.filter(issue => issue.state === 'closed').length;
            const progress = totalIssues > 0 ? Math.round((closedIssues / totalIssues) * 100) : 0;
            
            // Update milestone description with progress
            const updatedDescription = milestone.description?.replace(
              /Progress: \d+%/,
              `Progress: ${progress}%`
            ) || `Progress: ${progress}%`;
            
            await github.rest.issues.updateMilestone({
              owner: context.repo.owner,
              repo: context.repo.repo,
              milestone_number: milestone.number,
              description: updatedDescription
            });
            
            // Auto-close milestone if 100% complete
            if (progress === 100 && totalIssues > 0) {
              await github.rest.issues.updateMilestone({
                owner: context.repo.owner,
                repo: context.repo.repo,
                milestone_number: milestone.number,
                state: 'closed'
              });
              
              // Create completion comment
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `üéâ Milestone "${milestone.title}" Completed!`,
                body: `
                ## üéâ Milestone Completed!
                
                **${milestone.title}** has been automatically completed!
                
                ### Statistics
                - Total issues: ${totalIssues}
                - Completed: ${closedIssues}
                - Progress: 100%
                
                Great work team! üöÄ
                `,
                labels: ['milestone', 'completed', 'celebration']
              });
            }
          }

  # Performance monitoring for automation
  automation-monitoring:
    name: Automation Performance Monitoring
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule'
    
    steps:
    - name: Monitor automation performance
      uses: actions/github-script@v7
      with:
        script: |
          // Get workflow runs for the last 7 days
          const sevenDaysAgo = new Date();
          sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
          
          const workflows = await github.rest.actions.listWorkflowRuns({
            owner: context.repo.owner,
            repo: context.repo.repo,
            created: `>=${sevenDaysAgo.toISOString()}`
          });
          
          const stats = {
            total: workflows.data.workflow_runs.length,
            successful: workflows.data.workflow_runs.filter(run => run.conclusion === 'success').length,
            failed: workflows.data.workflow_runs.filter(run => run.conclusion === 'failure').length,
            cancelled: workflows.data.workflow_runs.filter(run => run.conclusion === 'cancelled').length
          };
          
          const successRate = stats.total > 0 ? Math.round((stats.successful / stats.total) * 100) : 0;
          
          // Create monitoring report
          const report = `
          ## üìä Automation Performance Report
          
          **Period:** Last 7 days
          **Generated:** ${new Date().toISOString()}
          
          ### Workflow Statistics
          - Total runs: ${stats.total}
          - Successful: ${stats.successful}
          - Failed: ${stats.failed}
          - Cancelled: ${stats.cancelled}
          - Success rate: ${successRate}%
          
          ${successRate < 80 ? '‚ö†Ô∏è **Warning:** Success rate below 80%. Please review failed workflows.' : '‚úÖ Automation performance is healthy.'}
          `;
          
          console.log(report);
          
          // Create issue if success rate is low
          if (successRate < 80 && stats.total > 5) {
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: '‚ö†Ô∏è Automation Performance Alert',
              body: report,
              labels: ['automation', 'performance', 'alert']
            });
          }